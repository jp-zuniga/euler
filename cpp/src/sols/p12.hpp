// https://projecteuler.net/problem=12
// -------------------------------------------------------------------------------------
// The sequence of triangle numbers is generated by adding the natural numbers.
// The formula for a specific triangle number, T-n is:
// T-n = n(n + 1)) / 2
// -------------------------------------------------------------------------------------
// Find the first triangle number with over 500 divisors.

// optimize < 10ms

#include <chrono>
#include <cstdint>
#include <iostream>
#include <unordered_map>
#include <vector>

#include "include/primality.hpp"
#include "include/timer.hpp"

using namespace std::chrono;

inline uint64_t count_divisors(const uint64_t &num) {
  uint64_t divisors = 1;
  std::vector<uint64_t> factors = prime_factors(num);

  // dictionary where:
  //   - keys: prime factors of num
  //   - values: prime factor's exponent (how many times it divides into num)
  std::unordered_map<uint64_t, uint64_t> factor_counts;

  // find each prime factor's exponent
  for (const uint64_t &prime : factors) {
    factor_counts[prime]++;
  }

  // find number of divisors with the divisor formula:
  // (a + 1) * (b + 1) * (c + 1) * (...)
  // where a, b, c = prime factors' exponents

  for (const auto &[factor, exponent] : factor_counts) {
    divisors *= (exponent + 1);
  }

  return divisors;
}

inline void solve_p12() {
  auto start = steady_clock::now();

  constexpr uint64_t divisor_count = 5e2;
  uint64_t n = 0;
  uint64_t triangle_num = 0;
  uint64_t divisors = 0;

  while (true) {
    n++;
    triangle_num = (n * (n + 1)) / 2;
    divisors = count_divisors(triangle_num);

    if (divisors > divisor_count) {
      break;
    }
  }

  auto end = steady_clock::now();

  std::cout << "First triangle number with more than " << divisor_count
            << " divisors: " << triangle_num << "\n";

  print_time(start, end);
}
